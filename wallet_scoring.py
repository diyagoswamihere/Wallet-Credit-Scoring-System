# -*- coding: utf-8 -*-
"""wallet_scoring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W8jgCOGKSu_WU0gWWn3XQoAY1m_Vgp5p
"""

!pip install pandas numpy matplotlib seaborn

"""**Data Loading and Preprocessing**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Loading the json file
df= pd.read_json("user-wallet-transactions.json")

# Flattening the actionData dictionary into columns
df= df.join(df['actionData'].apply(pd.Series))

# and converting amount to float for calculations
df['amount']=df['amount'].astype(float)
# Converting timestamp to datetime
df['timestamp']= pd.to_datetime(df['timestamp'], unit='s')

print(df.head())

"""**Feature Engineering**"""

# Calculating features for each wallet

features_df = df.groupby('userWallet').agg({

    'action':'count',
    'timestamp': ['min', 'max'],
    'amount': [
        ('total_deposits', lambda x: x[df['action'] =='deposit'].sum()),
        ('total_borrows', lambda x: x[df['action']=='borrow'].sum()),
        ('total_repays', lambda x: x[df['action'] =='repay'].sum()),

        ('total_redeems', lambda x: x[df['action']== 'redeemunderlying'].sum())
    ],
    'assetSymbol':'nunique'
}).reset_index()

# Flattening the column names
features_df.columns=[
    'userWallet', 'total_transactions','first_timestamp', 'last_timestamp',
    'total_deposits','total_borrows', 'total_repays', 'total_redeems','unique_assets'
]
# Calculating time span

features_df['time_span_days'] =(features_df['last_timestamp']-features_df['first_timestamp']).dt.days

# Calculating liquidation count

if 'borrower' in df.columns:

    liquidation_df= df[df['action']== 'liquidationcall'].groupby('borrower').size().reset_index(name='liquidation_count')
    liquidation_df.rename(columns= {'borrower':'userWallet'},inplace=True)
    features_df= features_df.merge(liquidation_df, on='userWallet', how='left').fillna({'liquidation_count': 0})

else:

    features_df['liquidation_count']=0

# Saving to csv
features_df.to_csv('wallet_features.csv', index= False)

# just for checking
print(features_df.head())

"""**Setting up the scoring function**"""

def calculate_score(row):
    score=500 #Base score

    time_bonus=min(row['time_span_days']/ 365, 1)*200
    repayment_bonus=100 if row['total_borrows'] ==0 or row['total_repays']>= row['total_borrows'] else (row['total_repays']/max(row['total_borrows'], 1))*100
    liquidation_penalty=min(row['liquidation_count'] *100,500)
    diversity_bonus=min(row['unique_assets'] /5, 1) *100
    total_score=score +time_bonus +repayment_bonus+ diversity_bonus -liquidation_penalty
    return max(0,min(1000,total_score))

# Apply the scoring function
features_df['score']=features_df.apply(calculate_score, axis=1)

features_df[['userWallet', 'score']].to_csv('wallet_scores.csv', index=False)
print("Scores saved to wallet_scores.csv")

"""**Analyzing the results**"""

# Plot score distribution
plt.figure(figsize=(10, 6))
sns.histplot(features_df['score'],bins =10,kde= True,color = '#1f77b4')
plt.title('Distribution of Wallet Scores')

plt.xlabel('Score')
plt.ylabel('Frequency')

plt.savefig('score_distribution.png')
plt.close()

score_summary=features_df['score'].describe()
print("Score Distribution Summary:")
print(score_summary)

low_score=features_df[features_df['score']< 400]
high_score=features_df[features_df['score']> 600]

# this is for analysis.md
print(f"\nLow score wallets (0-400): {len(low_score)}")

if len(low_score)> 0:
    print(f"Average liquidation count (low scores): {low_score['liquidation_count'].mean():.2f}")
    print(f"Average time span in days (low scores): {low_score['time_span_days'].mean():.2f}")
    print(f"Average unique assets (low scores): {low_score['unique_assets'].mean():.2f}")

else:
    print("No wallets in low score range (0-400).")
print(f"High score wallets (600-1000): {len(high_score)}")

if len(high_score)> 0:
    print(f"Average liquidation count (high scores):{high_score['liquidation_count'].mean():.2f}")
    print(f"Average time span in days (high scores): {high_score['time_span_days'].mean():.2f}")
    print(f"Average unique assets (high scores):{high_score['unique_assets'].mean():.2f}")
else:
    print("No wallets in high score range (600-1000).")